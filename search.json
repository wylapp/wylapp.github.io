[{"title":"BERT的参数应该如何冻结？","date":"2023-09-02T13:12:11.000Z","url":"/2023/09/02/bert-freeze/","tags":[["python","/tags/python/"],["BERT","/tags/BERT/"],["transformers","/tags/transformers/"]],"categories":[[" ",""]],"content":"BERT是极具代表性的预训练语言模型，几乎是现在很多语言理解任务，甚至是数据挖掘任务的基座。由于种种原因，部分任务在使用BERT的时候需要冻结部分参数，或者只引入部分层，因此需要对BERT中的参数进行冻结（或解冻）处理。 只引入部分层这里的讨论全都基于12层的bert-base-uncased展开，其他模型变体也是类似的。一般来说底层transformer的输出包含更多的词语级信息，高层transformer的输出更多包含句段级的信息。如果想要只使用最下面8层transformer结构，则可以直接在初始化时进行设定。 config.num_hidden_layers = 8就是对层数的设定，通常来说都是从最下层开始往上数n层进行保留，很少有截取中间几层进行保留或者只保留最高几层的。所谓的保留，就是正常加载预训练时得到的参数，不保留的层直接将参数随机化，而且模型的运算过程也不会跟他们有关。在这样的设定下初始化BERT之后，会输出下列提示，提醒用户注意下列层并未初始化。 引入部分层的结果是会改变hidden_states的形状，这是因为没有初始化的层根本不参与运算，自然也就没有输出。 需要注意的是，尽管这里这保留了8层，但是最终hidden_states中的隐藏层向量却有9个，这是因为最底层的embedding层有一个单独的输出结果也被纳入其中了。如果想取第7层的输出，代码应该写作bert_out.hidden_states[7]而不是bert_out.hidden_states[6]。 关于BERT的输出，可以参考 冻结部分层的参数首先来查看BERT的各层名称及是否需要梯度（冻结与否），默认所有层均需要梯度 输出如下 我们要关注的，就是所有包含encoder.layer的层，下面给出两种很简单的方式，来对特定层参数进行冻结。 这两种效果是等价的，但是都不会冻结最底层embedding层的参数，实际使用中embedding层对模型整体效果的影响不大。如果真的必须冻结embedding层，可以将第一种方法改为如下代码。 "},{"title":"处理pandas读取tsv文件时切分错误问题","date":"2023-07-20T03:26:53.000Z","url":"/2023/07/20/pandas-tsv/","tags":[["pandas","/tags/pandas/"],["python","/tags/python/"]],"categories":[[" ",""]],"content":"使用pandas读写结构化表格文件很常见，但是经常遇到读取文件不完整的问题。 在python中，为了从外部读取结构化的表格数据，最常用的方法就是pandas读取，并存为DataFrame结构。如果是逗号分隔的表格，文件名后缀一般是csv，制表符分隔的文件，结尾一般是tsv. 这两种文件都使用特殊符号进行列的分隔。如果列内部本身包含了分隔符号，则程序解析的时候会发生误判，因此pandas中规定，列本身被引号包裹，则忽略内部的分隔符号。问题在于有些数据中存在不闭合的引号，会引发错误解析。因此需要关闭这条规则。 修改如下: 如果引号本身也具有特殊含义，而列内部又包含特殊分隔符，还可以将quotechar改为其他字符。"},{"title":"常用Linux管理命令","date":"2023-05-10T03:30:13.000Z","url":"/2023/05/10/linux-mgrscrpts/","tags":[["linux","/tags/linux/"]],"categories":[[" ",""]],"content":"维护课题组服务器的时候要用到很多常用命令，每次都去百度搜索太浪费时间了，这里做一个总结归纳。 创建用户 如果需要添加sudo权限，修改/etc/group文件 在后面追加用户名 删除用户 -r删除所有附属文件 时间维护网络同步时间使用http时间戳戳同步，NTP协议校内用不了 修改为中国标准时间CST 开启公钥登录需要编辑/etc/ssh/sshd_config文件，默认情况是开启密码登录的，如果要开启公钥登录，则需要添加配置 "},{"title":"家庭网络优化记录(I)","date":"2022-06-15T16:00:00.000Z","url":"/2022/06/16/net1/","categories":[[" ",""]],"content":"这个系列预计会有多篇文章，每一篇聚焦一两个问题，在这一篇主要考虑IPv6的问题。IPv6已经是大势所趋，未来一定会大规模部署使用，实际上现在的骨干网早已支持该协议，真正的痛点出在“最后一公里”，也就是家里的路由器上。绝大部分2018年之前购买的路由器内部完全没有或部分残缺IPv6协议栈，即便现代操作系统普遍支持该协议，在这样的网络环境下，难以真正分配得到可用v6地址。 路由器残缺的协议栈现在接入宽带普遍采用FTTH模式，在光缆中就是光信号，只有到了光电转换这（也就是俗称的光猫），才能看到以太网帧。由于IP协议是工作在第三层的，因此和路由功能直接相关。目前家中的主要网络设备为一台光猫和一台路由器。光猫改为桥接模式以后，相当于工作在第二层，而路由器通过ppp协议接入互联网，在此之上提供路由功能，属于第三层。 遇到的第一个问题，现有的这台路由器不支持ppp拨号时协商IPv6地址。查证过程如下：首先需要开启路由器的telnet功能，需要进入shell来查看拨号日志。在登入网页管理端以后，访问该网址： 后，页面提示load telnetd success.表示开启telnet成功，会话在网页管理端退出前有效。 使用shell进入telenet，用户名为root，密码Fireitup，在路径/var/pppoe.log查看到拨号日志。 这是一份很标准的链路协商日志，关键问题就出在了Unsupported protocol这一句，拨号程序不认识IPv6的链路控制协议，自然也没法获得IP地址，也就是说协议栈是残缺的。但也不是说这个路由器就没用，在后面会看到，还是一定程度上可以利用的。 SLAAC和DHCPv6既然路由器从拨号这一关就不认识IPv6协议，那也就没法继续直接利用，自行修改固件也不太可能。于是转战研究光猫。光猫的硬件生产年份为2017年，经过查看管理界面的代码，部分注释标注2021年，因此可以认为该光猫获得了运营商下发的更新。 在网络管理界面，改变模式为“路由”，开启FullConeNAT，以期能够达到NAT1。重点是下方的IPv6配置，一定要勾选获取前缀，获取方式就是PrefixDelegation，这个地方的配置对于后续手机等设备能否正常获取地址非常关键。之后进入用户侧管理，对于IPv4的配置不用改动，主要是注意IPv6部分。在最开始的测试中，如果开启DHCPv6则所有的安卓手机均无法获得IPv6地址，其余设备正常。在反复查证后了解到，Android系统只支持以SLAAC (Stateless Adress AutoConfigure，无状态自动地址配置)方式获得IPv6地址，因此这里关闭DHCPv6服务器，不勾选“地址信息通过DHCP获取”。刚才讲到的前缀，也就决定了这两种方式分配地址的方式的不同。IPv4在拨号时只会获得一个地址，IPv6获取的是一个前缀，在前缀后面的部分是可以自定义的。使用光猫拨号分配得到的是一个&#x2F;56地址块，在使用SLAAC的情况下，&#x2F;56地址块可以进一步划分得到2^8&#x3D;256个&#x2F;64地址块。设备单拨地址协商的大致过程如下： 设备发送RS报文，请求地址信息 网关发送RA报文，包含前缀和前缀长度等信息 设备根据前缀长度，生成后半部分地址（接口ID） 邻居发现，检测是否重复地址(DAD) 在RA报文中，M,O标记就是图片中的“地址信息通过DHCP获取”和“其他信息通过DHCP获取”。所谓无状态，就是不存在全局的地址服务器，内部维护该自治系统下的全部地址分配状态信息。 M O 含义 描述 1 1 地址和DNS等都从DHCPv6服务器取得 Stateful DHCPv6 0 1 地址使用RA广播的prefix+EUI-64计算出来的接口地址,DNS和其他服务器从DHCPv6取得 Stateless DHCPv6 0 0 完全的Stateless配置,仅地址使用RA广播的prefix+ EUI-64计算出来的接口地址 Stateless AutoConfiguration 其中，无状态DHCPv6是最常用的配置方式。在使用了上述配置以后，将路由器改为AP模式，或关闭路由器自带的DHCP功能后，将光猫千兆口与路由器LAN口连接，将无线路由器降级为二层交换机使用，也就无视了路由器内部的三层及以上协议栈。至此，所有设备均可分配得到可用的IPv6地址。"},{"title":"TLS证书链缺失导致小程序网络请求失败","date":"2022-04-13T04:08:00.000Z","url":"/2022/04/13/echo_424/","tags":[["TLS","/tags/TLS/"],["小程序","/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[[" ",""]],"content":" 引子我们开发了一款微信小程序，但是上线的时候遇到了很奇怪的事情：在iOS端有时能访问，有时不能访问；在Android端完全不能访问。我们的后端服务部署在校内服务器，在外部通过xxx.xxxx.xxx.xx访问。在电脑端不管是使用接口测试工具还是浏览器访问，我们的后端都是正常可访问的。 深入前端同学利用小程序调试工具，最早向我们反馈了可能是证书问题。由于手头没有小程序的源码，我自己动手写了一个demo复现这个错误。复现的代码非常简单，就是发起一个HTTPS请求，并把响应体打印在控制台。整个复现过程非常顺利，同样的错误也出现了，这次我看到了控制台输出的详细错误，错误代号-2:net::ERR_FAILED。其实这个时候就初步判断不是应用层的问题了，问题至少出在网络层或运输层。 请注意图中黄色部分，红色部分与此问题无关。回想到整个业务的网络拓扑结构，由于内网环境的特殊性，还部署了WAF过滤请求，用户端不是直接与服务端进行交互，这中间还涉及到内网内部的转发，因此还需要进一步证实具体问题。 简化的网络拓扑结构如上图所示。我们在应用服务器上找到了前几次访问的日志，尽管在小程序上没有得到响应，日志显示这些请求被正常响应并返回，这意味着用户发出的请求通过了网关，被核心路由正确转发到了应用服务器，我们的应用服务器也做出了正确的响应。至此可以判断，问题只能出在是网关及以外的地方。 为了查看请求从用户设备到网关直接到底发生了什么情况，我对手机进行了抓包分析，使用的工具是charles。Charles使用自签名证书实现中间人嗅探，从而实现侦听SSL请求。奇怪的是，进行抓包的时候请求一切正常，以TLS1.2协议握手成功，手机上也能访问了。因此初步判断问题还是出在了证书上，使用charles抓包时，证书信任过程不再交给手机处理。自然而然地我想到，如果手机上根本不发出HTTPS请求会怎样？ 为了验证SSL证书和这个错误的关系有多大，我将小程序中网络请求降级为HTTP，在真机验证一切正常。但由于微信要求所有请求必须为HTTPS，所以这个问题不能以降级为HTTP的方式解决。 证书的再验证微信官方提示使用myssl.com进行证书检测，该网站始终认为我们的证书没有问题，这也是解决这个问题耗费如此长时间的原因。在所有证据均指向证书错误以后，我们改用其他工具重新测试证书，果然发现了问题。myssl.cn上检测提示，服务器中间证书缺失。  结论我们认为，问题可能出在网关上的SSL证书配置有误，遗漏了中间证书。对绝大部分电脑浏览器而言，缺失的中间证书会自动补全，不影响访问。而小程序中的全部网络请求基于腾讯X5内核实现，根据Android平台的特点及安全性考虑（请求伪造和中间人攻击），腾讯有可能在软件层面屏蔽了证书链缺失的HTTPS响应，这也就造成了无法访问的假象。 后续经机房人员查证，问题出在WAF上的HTTPS防护功能，在设备厂家研发人员的指导下调整恢复正常。"},{"title":"CS224N-Assignment#4 Review","date":"2022-04-01T09:55:00.000Z","url":"/2022/04/01/echo_420/","categories":[[" ",""]],"content":"We are now providing accelerated docs browse service for [pytorch][1]. Following the instruction document, the procedure should be at ease. Limited by the computing resource, my model is not trained thoroughly, resulting in BLUE≈22.54, which is acceptable according to the handout.The scaffold may be written under the Python2 environment, to run in Python3, some lines need to be altered. nmt_model.py, line 438, alter to: This problem may be caused by the different behavior of operator slash and double slash between Python2 and Python3. Additionally, to run the test script, you should first make a directory called output. In the following part, I’d like to review coding skills and some nasty problems. LSTM and LSTMCellPytorch provides both LSTM and LSTMCell, LSTM accepts the sequential data elements simultaneously, and will get a bunch of hidden states. LSTMCell gives you the ability to manually operate one LSTM cell at a step. LSTM could be configured as bidirectional and multiple layers. If bidiretional&#x3D;True, it’s a double layer RNN, one forward, the other backward, which leads hidden state and cell state to double-sized. Pad and PackSequential data should be padded to the same length before feeding to RNN. However, token contributes nothing to the training procedure. pack_padded_sequence packs a batch of padded sequence and send them to the RNN, pack_padded_sequence does vice versa. Squeeze and UnsqeezeThese two methods are widely used for tensor reshaping. It is strongly advised to specify which dimension this operation is needed. By default, squeeze will compress all 1-item dimensions, which may cause unpredictable consequences."},{"title":"RDBMS与混合设计范式","date":"2022-02-19T13:32:00.000Z","url":"/2022/02/19/echo_416/","categories":[[" ",""]],"content":"最开始学数据库系统课程的时候，接触的都是普通的关系型数据库。关系型数据库的表结构（scheme）定义是先于数据存储的，这也就意味着数据项的结构（即数据项内部包含的数据元素，映射为数据库的列）发生改变，则需要整体调节表结构。在面向对象程序设计中，一张数据库中的表对应着一个类，即每一行能实例化为一个对象。频繁的表结构改变将给数据维护带来很大麻烦，包括但不限于以下问题及风险： 性能开销的增加。改变表结构某些情况下会导致索引重建，索引重建又有可能引发雪崩 数据丢失的风险。由于易失性普遍存在于存储变更及数据转换过程中，表结构的改变对数据完整性造成威胁 编码效率下降。 这就引申出一个问题，如何在不改变表结构的条件下，改变存储的数据项。这个问题在2019年利用flask实现第一个web项目的时候就想到了，直到后来系统地学习过数据结构和数据库系统这两门课程以后，才开始以更专业的视角审视这个问题。在数据库层面可以选择非关系型数据库（例如mongoDB），这就摆脱了“必须先设计模式再存数据”这个限制。这个思路在实现实验室的科研项目时使用过，存在最主要的问题是外键限制不完善：id引用需要多轮查询，全引用不能动态更新。其次序列化与反序列化工具链在各种编程语言中不成熟。 在做智慧党建项目的时候，这个问题更加凸显。在长期实践中我的做法是，将一部分重要的、很难改变的字段固定入数据库模式设计中，其余信息组织放入一个额外字段中。组织这些其余信息的方式就是利用JSON格式，保持数据项之间的相对关系。由于很多数据库现在已经支持json字段，因而这是一种可行的做法。 常见的小项目中，多使用MySQL数据库，但是直到5.7版本才完整支持此类型，在此之前的版本只能使用text字段存储json串。如果使用text字段存储串，就无法在此字段上构建索引，这也就不支持高级检索方式。实际上直到8.0版本，在json字段上的高级索引功能也不如PostgreSQL做得好，因此十分建议使用混杂设计模式的应用切换到使用PostgreSQL数据库。 在PostgreSQL数据库中，定义json字段一共有两种类型，其中json类型是为了兼容，而jsonb类型支持的高级索引功能更多。一般来说，如果需要使用json类型，则定义为jsonb就足够了。关于在此字段上的高级检索方式，可以参考PostgreSQL官方文档。值得注意的是，如果在此基础上开发web应用，则SQLAlchemy框架提供了非常好用的orm映射，基本上完整地支持上述检索中使用的运算符。"},{"title":"博客迁移的第一篇记事","date":"2022-01-30T14:13:00.000Z","url":"/2022/01/30/echo_413/","categories":[[" ",""]],"content":"从2011年第一次在虚拟主机上部署WordPress到今天，已经跟WordPress打了十多年交道。WP虽然在不断更新，功能也在不断强大，但是对于个人博客来说越来越臃肿。看似插件和主题数量繁荣，实则缺少简单的方式对博客进行自定义修改，繁复的页面渲染也给性能优化带来不小挑战。春节前夕借着闲暇时间，将博客迁移到typecho架构。在这个随便写点东西的地方，简洁轻巧就足够了。"},{"title":"修复Python爬虫SSL错误","date":"2022-01-30T06:23:00.000Z","url":"/2022/01/30/echo_412/","categories":[[" ",""]],"content":"python的网络套接字部分依赖外部标准ssl库。一般在Windows上这个问题不大，Linux上需要正确安装`libssl`并且有可用的ssl.h头文件，这是很多问题的源头，因为有些Linux发行版使用了过时的libssl版本，解决依赖冲突会很麻烦。如果系统中的ssl库版本不符合要求，则安装后的python不能使用ssl访问（pip的使用都会受到限制）。 在mac上我之前以为这个问题不大，因为bsd系统套接字部分的实现非常成熟，但是系统升级11.5以后就没再用过python写爬虫。今天再次写爬虫的时候发现报了很多关于ssl的错误。根本原因是缺乏本地CA证书，因此我们添加上就行了。证书可以手动添加，但是有更简单的办法自动添加。在python安装完毕的软件目录内，双击执行Install Certificates.command，会自动诊断并修复本地证书错误。至此问题解决。上述办法是查StackOverflow找到的，CSDN上没有一个答案是靠谱的！更新今天在Windows上写爬虫居然也出现了类似的问题，而且不能通过上述脚本自动解决，手动处理过程倒也不算太复杂。在Windows平台上出现ssl错误的环境大多使用anaconda创建。首先需要确定本地证书目录： 如果上述目录根本不存在，则手动创建到ssl目录一层。之后需要使用certifi模块获取合规的证书： 将上述cacert.pem文件拷贝到前述ssl文件夹即可。"},{"title":"axios(或jQuery)异步下载文件的有效方法","date":"2021-11-06T12:07:00.000Z","url":"/2021/11/06/echo_363/","categories":[[" ",""]],"content":"相当长一段时间，我做的项目中下载文件都是通过点击&lt;a href=&quot;link&quot;&gt;&lt;/a&gt;这样的链接实现的，这种做法虽然比较简单，但是也存在一定弊端。比如后端接口一旦生成文件失败，点击这个链接后打开的页面就不会自动关闭，带来了很不好的用户体验；下载文件的操作完全可以异步实现，目前这种做法是同步的，显然效率不高。 借助jQuery,axios我们可以轻松发起XHR，这就意味着距离实现下载功能，只差在如何将请求的对象保存在本地这一步。首先回顾服务端是如何将文件转换为流的方式发送到前端的。 服务端生成文件字节流 这里以Python为例。使用BytesIO可以轻松地将磁盘文件转换为内存文件。实际上BytesIO对象的读写过程对用户是透明的。绝大部分利用磁盘文件指针进行读写的情景，都可以使用BytesIO对象代替 上面这一段是从数据库中查询订单信息，并利用pandas.DataFrame存储为Excel表格。我们注意到，to_excel()方法第一个参数原本应该是文件指针或路径，但是这里是一个BytesIO对象。在视图层，我们将这个对象发送给前端。 这个HTTP响应和普通的响应不太一样。最主要的特征是响应头的Content-Type字段值为application/octet-stream，octet是‘八’的意思，简单说就是8比特流，也就是字节流。如果不加上这一字段，浏览器就会将文件按照默认文本编码，将这些字节编码后直接显示在屏幕上，结果就是满屏幕的乱码，没人能看懂。在RFC2046中有关于各种取值的详细规定，以及收到字节流以后应该进行的操作。 The recommended action for an implementation that receives an &quot;application/octet-stream&quot; entity is to simply offer to put the data in a file, with any Content-Transfer-Encoding undone, or perhaps to use it as input to a user-specified process. 至此我们已经知道了最重要的一点，浏览器何时会将响应体直接存储为文件，而不是显示出来，取决于响应头中的一些字段。后续利用axios以及jQuery实现异步文件下载，就是利用了这一特点。 直接使用超链接不行吗？ 直接使用超链接，在大多数情况下没问题。但有个别时候却很影响用户体验，因为点击超链接后浏览器往往会跳转打开一个新的窗口或选项卡，在下载开始后，这个页面才能自动关闭。这个过程听起来没什么问题，但是下面这两种情况可能对用户并不友好： 服务端实时生成文件，数据量较大时需要等待很久才能开始下载，浪费了等待时间 服务端出错，页面将出现用户看不懂的错误信息，并且需要用户手动关闭 一些接口在请求时需要附加额外的header，或者使用POST方法，超链接无法实现 上图是真实开发中的接口。很明显后端开发人员想要告知用户下载文件时出错的原因，并且提供了可供前端使用的JSON响应体，但是前端人员只是使用了超链接来处理下载，恰好就遇到了上述的第二个问题。面对突然弹出的错误页面，用户会感到手足无措。 上手异步文件下载 已经有太多成熟的js库可以发起XHR(XMLHttpRequest)请求了，也许XHR这个名字有点陌生，但是说起AJAX(Asynchronous Javascript And XML)，大家再熟悉不过了。下面用axios实现异步下载这一过程 下面我们深入探访一下这几行代码执行时到底发生了什么 首先可以确定的是，axios支持Promise写法，能够很好地处理请求成功与失败的情况。请求如果成功，我们使用Javascript中的blob对象承接原本请求得到的字节流；如果失败，那么我们可以给用户友好的提示信息。 blob对象内部本质上是二进制流，但是八个一组编排一下，也就是字节流了。在异步文件下载这个过程中，blob对象只是一个中间媒介。 可以看到，在这个过程中我们创建了一个ObjectURL对象，对象URL是实现这一过程的核心，每一个对象url都拥有一个全局唯一的地址，例如上图中的blob:，他们都唯一对应着一个File对象，File建立在blob之上，也就是刚刚承接先行请求响应体的blob对象。a节点的链接直接对应着ObjectURL对象，在上面的代码中我们模拟点击了这个链接，从而触发浏览器的下载机制，也就实现了异步下载。正是由于模拟点击，而且链接的blob对象已经缓存在本地，所以浏览器不会跳转新的页面，而是直接进行下载。"},{"title":"word2vec简单实现","date":"2021-10-29T03:27:00.000Z","url":"/2021/10/29/echo_353/","categories":[[" ",""]],"content":"## 梗概 word2vec算是embedding中近年来比较火的方法了。从实践角度来讲有CBOW和skip-gram两套思路，一种是从context推断local，而另一种是从local推断context。但是我们其实并不关心模型的输出，而只关心模型内部的隐层。 核心代码使用pytorch构建了一套标准pipeline 这套代码对于网络核心层采用了网上提供的版本，采用了nn.Parameter模块。最早的版本使用了torch.nn.Linear来完成核心投影层的构建，因为Linear模块是可以定义输入维数和输出维数的，对于$y&#x3D;wx$这样的线性回归，如果$y\\in \\mathbb{R^v}, x\\in \\mathbb{R^n}$, 那么只要$w \\in \\mathbb{R^{n\\times v}}$就能完成维度的映射。实际上使用线形层是没有问题的，只不过最后输出词向量的时候需要使用第一层的权重矩阵点乘词语的onehot向量。下面给出修改后的部分代码： 结果 尝试在模型中开启Linear层中加入偏置量，发现也可以得到预期的结果！ 这是代码运行的结果。其中使用Linear模块epoch在200就可以达到很好的映射效果，但是如果使用Parameter模块，达到同样的映射效果至少需要linear两倍的epoch。"},{"title":"uWSGI应用发布随笔","date":"2021-07-17T14:56:00.000Z","url":"/2021/07/17/echo_258/","categories":[[" ",""]],"content":"前言 从2019年开始接触Python-Web开发开始，大大小小的应用也做了十几个了。从一开始为了部署一个应用研究好几天，到后来摸清了所有过程几分钟就能完成部署工作，确实感受到人的认知过程是螺旋上升的。在这个过程中也积累了很多经验，在这篇随笔中记录一下。 一些重要的原则 在任何情况下，都不应该使用开发服务器部署应用 不能直接将uWSGI直接暴露在外网（即不应该使用http模式） 反向代理服务器nginx是首选，如果条件确实不允许，也可以使用apache 最好不要使用root账号部署应用 一些经验 如果使用frp，可以使用TCP socket，并将这个端口映射到外网，在外网的服务器做反向代理 可以将静态文件交给nginx处理 Apache配置起来比nginx复杂得多 uWSGI配置模版 需要在项目路径下保存配置文件，通常的命名方式是myconfig.ini，对于flask和Django的配置方式还有所不同。 flask 下面展示基于flask开发应用的配置文件： 需要注意的是，flask开发应用都会实例化一个app对象出来，在上面的配置中我们要让uwsgi服务器找到这个对象并执行。因此main.py文件中需要包含这样的语句： Django 对于Django项目，配置起来就相对简单一下，示例的配置文件如下： nginx反向代理配置 端口什么的就不用说了，需要在vhost下面添加以下路由： 保存配置以后，重启即可，这是发现已经可以访问web应用了。 如果还有静态文件访问需求，还需要在nginx中配置静态文件路由，具体配置如下 uWSGI的启动和重载 使用配置文件启动应用服务器 重载配置和代码 "},{"title":"编译原理实验报告提交","date":"2021-06-08T03:26:00.000Z","url":"/2021/06/08/echo_235/","categories":[[" ",""]],"content":"6-13 已截止 请使用标准实验报告模版，请点击下载实验报告模板 请点击下面的链接，上传提交实验一 请点击下面的链接，上传提交实验二  上交的是两个实验的实验报告，为word版，命名为学号-姓名。 请尽快完成并提交，感谢大家配合！"},{"title":"快读-模板","date":"2021-03-05T07:34:00.000Z","url":"/2021/03/05/echo_226/","categories":[[" ",""]],"content":"其实就是省去了缓冲区同步的时间，把一切输入当作字符处理 "},{"title":"C++大数模版-面向对象实现","date":"2021-02-02T03:22:00.000Z","url":"/2021/02/02/echo_218/","categories":[[" ",""]],"content":"借鉴了一下比较规范的大数运算C++库，写了一套面向对象的大数运算库。存在的一点不足是下面的代码最低运行环境是C++11,如果不是的话，std::to_string()这个函数需要自己实现，再有函数式运算的办法还是比较麻烦，重载运算符会好一点。下面是加法的版本： "},{"title":"操作系统课程设计报告上交","date":"2020-12-29T08:23:00.000Z","url":"/2020/12/29/echo_199/","categories":[[" ",""]],"content":"2021.1.4 已截止 操作系统实验报告采用自助上交方式，请点击下方的链接进入文件存储系统：文件存储系统(点击这里）请注意，不要修改账号密码，不要动别人的文件，所有操作都有日志记录。请按照老师的要求命名报告文件，最后交的只有一个word文档。登录的账号和密码都是“计科三班”的全拼，在1月4日以前随时可以上传报告，如果觉得自己之前写的不好，可以删掉并重新上传。上传方法见下图："},{"title":"纪念一下，matplotlib画出了想要的图","date":"2020-12-17T13:27:00.000Z","url":"/2020/12/17/echo_160/","categories":[[" ",""]],"content":" "},{"title":"NFS读写性能测试","date":"2020-08-20T04:40:00.000Z","url":"/2020/08/20/echo_157/","categories":[[" ",""]],"content":"NFS读写性能测试 写测试 读测试 "},{"title":"在Linux下更换用户名","date":"2020-08-20T04:37:00.000Z","url":"/2020/08/20/echo_155/","categories":[[" ",""]],"content":"在Linux下更换用户名 Linux将用户名修改后，还需要修改 组名+家目录+UID这只会更改用户名，而其他的东西，比如用户组，家目录，UID 等都保持不变。以下操作使用root账号进行1、修改用户名 这只会更改用户名，而其他的东西，比如用户组、家目录、ID 等都保持不变。 注意： 直接执行上述命令会发现无法执行，因为原来的账户有进程在运行。你需要从要改名的帐号中登出并杀掉该用户的所有进程，要杀掉该用户的所有进程可以执行下面命令。 此操作可能导致图形化界面崩溃，请务必保证可以通过远程终端连接至主机，再使用上述命令。 2、修改家目录 上述操作只能把 /etc/passwd 中的用户目录配置修改，但是不能修改已经存在的目录名称。需要手动用户的家目录改名。3、修改组名 4、修改UID 5、检查 "},{"title":"Java之内部类和匿名类","date":"2020-04-08T07:51:00.000Z","url":"/2020/04/08/echo_139/","categories":[[" ",""]],"content":"1.内部类 在之前的学习中，我们了解了关于类的很多知识，但是那个时候我们写的类都只包含变量和方法。其实在Java中类的内部是可以潜逃类的，这样的嵌套类就叫做内部类。很多外部类和内部类具有很多共性，这里就不再赘述，今天主要想写一写内部类区别于外部类的特征。 内部类中也可以有静态方法和静态变量，但是这时就要求内部类本身必须是静态的； 外部类不能访问内部类的实例域，但是内部类可以访问外部类的实例域和静态域，需要借助.this关键字； 在公共类中可以实例化外部类，但是这时内部类不会被实例化；也可以单独实例化内部类 单独实例化内部类要求外部类已经实例化，并且要借助.new关键字 内部类之间可以相互实例化、调用。 下面的代码很好地展示了上述特性。 2.匿名类 匿名类其实是对内部类的扩展…… 作者按：在参考了无数的国内Java教材后，我还是选择了参考英文原版的&lt;Thinking in Java&gt;，与其看中文版作者语焉不详，不如坐下来仔细研读一下英文版教材。 "},{"title":"Java的抽象类、接口","date":"2020-04-02T11:02:00.000Z","url":"/2020/04/02/echo_109/","categories":[[" ",""]],"content":" 1.抽象类(abstract) 我们已经学习了Java面向对象的编程思想，前面我们也接触了简单的类的继承关系。但是现在考虑这样一个问题：当我们有大量的类需要继承自同一个类的时候，我们往往只将这些子类进行实例化，而从不关心父类的实例化问题。也就是说这个父类实际上对于用户来说是抽象的，这些子类实现的功能对用户来说是具体的。这些具体方法继承自父类的抽象方法，当一个类中存在抽象方法时，这个类就必须被声明为抽象类，抽象方法只包含声明部分，不包含方法体。 需要注意的是： 抽象类中可以不包含抽象方法；抽象类可以继承自非抽象类，也可以继承自抽象类；抽象类中可以包含static变量、方法，这些域不需要实例化可以直接调用；抽象类中可以包含普通方法，但是只能在其子类实例化后调用；抽象类中可以包含构造器，但是只能用于子类的构造，其本身不能被实例化；抽象类的子类必须对父类声明的全部方法补全方法体，不能只补其中几个。 下面的代码展示了相关的例子，可供参考。 2.接口(interface) 接口可以说是一种更极端的抽象思想，从字面上理解interface不光有“接口”的意思，它的更通俗的意思是“界面”。这也就是说，接口只提供了暴露到表面的东西，至于这些暴露出来的接口提供的功能，是由实现接口的方法完成的，更像是一个黑盒，或者说类之间沟通的一种协议(protocol)。因此接口具有下列特性： 接口中只能有常量和方法声明。其中常量也就是public static final限制，方法自动用public abstract限制。我们在写程序的时候可以只写public，编译的时候会自动添加；接口只能继承其他接口（允许多继承），不能继承其他类；一旦确定了某个类要实现某一接口，则必须实现接口中声明的全部方法，此类也可以有自己的方法；类可以同时实现多个接口，这一点弥补了Java不支持类的多继承的问题。（多继承不一定是一件好事，C++由于支持多继承而防止类之间产生二义性引入了虚基类、虚继承等概念，非常复杂）。 下面是一个示例程序，用来简单实现一下上面谈到的一些特性。 在这里，我们实际上利用了接口的回调(callback)技术。所谓回调技术是指，用一个接口变量可以存放实现接口的类的引用，通过此变量可以直接调用类中的接口方法。 至此，我们已经全部接触了Java中的三种引用类型：数组、类、接口。"},{"title":"如何快速打开文件夹位置的cmd窗口","date":"2020-03-04T02:02:00.000Z","url":"/2020/03/04/echo_68/","categories":[[" ",""]],"content":" 在日常学习中，我们总是会遇见这样的问题，如何才能快速地打开位于文件夹位置的cmd窗口。有的同学说，直接运行cmd然后切换目录不就成了？如果文件目录结构简单还好，目录结构一旦复杂就不好办了。本文总结了两种常用的解决方法供大家参考。 1.bat命令法 在需要打开cmd窗口的文件夹内，新建一个文本文件。在其中输入一下内容： 然后保存。之后将此文件的后缀改为.bat，双击运行即可进入对应路径的cmd窗口。如果需要管理员权限，可以右键点击，在弹出的菜单中选择“以管理员身份运行”。 2. 快捷菜单法 在需要打开cmd窗口的文件夹内，按住shift键，将光标移动至空白区域点击右键，弹出的菜单中会出现“在此处打开命令窗口”选项。win10系统中会出现“打开位于此处的powershell”。 注：以上方法仅针对Windows。 "},{"title":"tags","date":"2023-07-20T03:03:46.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2023-07-20T02:47:47.000Z","url":"/search/index.html","categories":[[" ",""]]}]